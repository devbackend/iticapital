// +build ignore

// Generate handler for read events from queue and write to channels
package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"text/template"
)

func main() {
	f, err := os.Create("event_handler_methods.go")
	if err != nil {
		log.Fatal(err)
	}

	defer f.Close()

	params := TplParams{
		Events: []string{},
	}

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, "events.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	for _, decl := range node.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}

		for _, spec := range gen.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}

			_, ok = typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}

			params.Events = append(params.Events, typeSpec.Name.Name)
		}
	}

	tpl.Execute(f, params)
}

var tpl = template.Must(template.New("").Parse(`// Code generated by go:generate handlergen.go; DO NOT EDIT.
package iticapital

import (
	"context"
	"encoding/json"
)

{{- range .Events }}

func (eh *eventHandler) handle{{ . }}(ctx context.Context, queueName string, ch chan<- *{{ . }}) {
	reader := eh.readerFactory.NewQueueReader(queueName)

ReadLoop:
	for {
		select {
		case <-ctx.Done():
			break ReadLoop
		default:
			msg, err := reader.Read(ctx)

			if err != nil {
				eh.logger.Error("failed read from " + queueName, err)
				break ReadLoop
			}

			event := &{{ . }}{}

			err = json.Unmarshal(msg, event)
			if err != nil {
				eh.logger.Error("failed unmarshall message from " + queueName, err)
				continue
			}

			ch <- event
		}
	}
}
{{- end }}
`))

type TplParams struct {
	Events []string
}




